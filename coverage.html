
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>yoga: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">codeberg.org/snonux/yoga/cmd/yoga/main.go (85.0%)</option>
				
				<option value="file1">codeberg.org/snonux/yoga/internal/app/app.go (75.0%)</option>
				
				<option value="file2">codeberg.org/snonux/yoga/internal/app/duration_cache.go (85.7%)</option>
				
				<option value="file3">codeberg.org/snonux/yoga/internal/app/filters.go (92.0%)</option>
				
				<option value="file4">codeberg.org/snonux/yoga/internal/app/load_progress.go (81.5%)</option>
				
				<option value="file5">codeberg.org/snonux/yoga/internal/app/loader.go (81.2%)</option>
				
				<option value="file6">codeberg.org/snonux/yoga/internal/app/model.go (83.3%)</option>
				
				<option value="file7">codeberg.org/snonux/yoga/internal/app/model_durations.go (87.5%)</option>
				
				<option value="file8">codeberg.org/snonux/yoga/internal/app/model_keys.go (78.2%)</option>
				
				<option value="file9">codeberg.org/snonux/yoga/internal/app/model_sort.go (92.6%)</option>
				
				<option value="file10">codeberg.org/snonux/yoga/internal/app/model_tags.go (64.4%)</option>
				
				<option value="file11">codeberg.org/snonux/yoga/internal/app/tag_commands.go (75.0%)</option>
				
				<option value="file12">codeberg.org/snonux/yoga/internal/app/view_helpers.go (84.4%)</option>
				
				<option value="file13">codeberg.org/snonux/yoga/internal/fsutil/path.go (83.0%)</option>
				
				<option value="file14">codeberg.org/snonux/yoga/internal/tags/tags.go (82.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "io"
        "os"
        "strings"

        "codeberg.org/snonux/yoga/internal/app"
        "codeberg.org/snonux/yoga/internal/fsutil"
        "codeberg.org/snonux/yoga/internal/meta"
)

const defaultRoot = "~/Yoga"

var (
        runApp = app.Run
        exit   = os.Exit
)

func main() <span class="cov8" title="1">{
        exit(run(os.Args[1:], os.Stdout, os.Stderr))
}</span>

func run(args []string, stdout, stderr io.Writer) int <span class="cov8" title="1">{
        fs := flag.NewFlagSet("yoga", flag.ContinueOnError)
        fs.SetOutput(stderr)
        rootFlag := fs.String("root", "", "Directory containing yoga videos (default ~/Yoga)")
        cropFlag := fs.String("crop", "", "Optional crop aspect for VLC (e.g. 5:4)")
        versionFlag := fs.Bool("version", false, "Print version and exit")
        if err := fs.Parse(args); err != nil </span><span class="cov0" title="0">{
                return 2
        }</span>
        <span class="cov8" title="1">if *versionFlag </span><span class="cov8" title="1">{
                fmt.Fprintf(stdout, "Yoga version %s\n", meta.Version)
                return 0
        }</span>
        <span class="cov8" title="1">root, err := fsutil.ResolveRootPath(*rootFlag, defaultRoot)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(stderr, "%v\n", err)
                return 1
        }</span>
        <span class="cov8" title="1">opts := app.Options{Root: root, Crop: strings.TrimSpace(*cropFlag)}
        if err := runApp(opts); err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(stderr, "error: %v\n", err)
                return 1
        }</span>
        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "fmt"

        tea "github.com/charmbracelet/bubbletea"
)

type teaProgram interface {
        Run() (tea.Model, error)
}

var programFactory = func(m tea.Model) teaProgram <span class="cov0" title="0">{
        return tea.NewProgram(m, tea.WithAltScreen())
}</span>

// Run bootstraps the Bubble Tea program with the provided options.
func Run(opts Options) error <span class="cov8" title="1">{
        model, err := newModel(opts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create model: %w", err)
        }</span>
        <span class="cov8" title="1">program := programFactory(model)
        if _, err := program.Run(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("run program: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "encoding/json"
        "errors"
        "io/fs"
        "os"
        "sync"
        "time"
)

type cacheEntry struct {
        DurationSeconds float64 `json:"duration_seconds"`
        ModTimeUnix     int64   `json:"mod_time_unix"`
        Size            int64   `json:"size"`
}

type durationCache struct {
        path    string
        entries map[string]cacheEntry
        mu      sync.Mutex
        dirty   bool
}

func newDurationCache(path string) *durationCache <span class="cov8" title="1">{
        return &amp;durationCache{path: path, entries: make(map[string]cacheEntry)}
}</span>

func loadDurationCache(path string) (*durationCache, error) <span class="cov8" title="1">{
        cache := newDurationCache(path)
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, fs.ErrNotExist) </span><span class="cov8" title="1">{
                        return cache, nil
                }</span>
                <span class="cov0" title="0">return cache, err</span>
        }
        <span class="cov8" title="1">if len(data) == 0 </span><span class="cov0" title="0">{
                return cache, nil
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(data, &amp;cache.entries); err != nil </span><span class="cov8" title="1">{
                cache.entries = make(map[string]cacheEntry)
                return cache, err
        }</span>
        <span class="cov8" title="1">return cache, nil</span>
}

func (c *durationCache) Lookup(path string, info os.FileInfo) (time.Duration, bool) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        entry, ok := c.entries[path]
        if !ok </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">if entry.ModTimeUnix != info.ModTime().Unix() || entry.Size != info.Size() </span><span class="cov8" title="1">{
                delete(c.entries, path)
                c.dirty = true
                return 0, false
        }</span>
        <span class="cov8" title="1">if entry.DurationSeconds &lt;= 0 </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov8" title="1">return time.Duration(entry.DurationSeconds * float64(time.Second)), true</span>
}

func (c *durationCache) Record(path string, info os.FileInfo, dur time.Duration) error <span class="cov8" title="1">{
        if c == nil || dur &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        if c.entries == nil </span><span class="cov0" title="0">{
                c.entries = make(map[string]cacheEntry)
        }</span>
        <span class="cov8" title="1">c.entries[path] = cacheEntry{
                DurationSeconds: dur.Seconds(),
                ModTimeUnix:     info.ModTime().Unix(),
                Size:            info.Size(),
        }
        c.dirty = true
        return nil</span>
}

func (c *durationCache) Flush() error <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">c.mu.Lock()
        if !c.dirty </span><span class="cov8" title="1">{
                c.mu.Unlock()
                return nil
        }</span>
        <span class="cov8" title="1">snapshot := make(map[string]cacheEntry, len(c.entries))
        for k, v := range c.entries </span><span class="cov8" title="1">{
                snapshot[k] = v
        }</span>
        <span class="cov8" title="1">c.dirty = false
        c.mu.Unlock()
        data, err := json.MarshalIndent(snapshot, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(c.path, data, 0o644)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

type filterState struct {
        name       string
        minEnabled bool
        minMinutes int
        maxEnabled bool
        maxMinutes int
        tags       string
}

type filterInputs struct {
        fields []textinput.Model
        focus  int
}

func (m *model) applyFilterInputs() error <span class="cov8" title="1">{
        name := strings.TrimSpace(m.inputs.fields[0].Value())
        minText := strings.TrimSpace(m.inputs.fields[1].Value())
        maxText := strings.TrimSpace(m.inputs.fields[2].Value())
        tags := strings.TrimSpace(m.inputs.fields[3].Value())

        filters := filterState{name: name, tags: tags}
        if err := populateMinFilter(&amp;filters, minText); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := populateMaxFilter(&amp;filters, maxText); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if filters.minEnabled &amp;&amp; filters.maxEnabled &amp;&amp; filters.minMinutes &gt; filters.maxMinutes </span><span class="cov0" title="0">{
                return errors.New("min minutes cannot exceed max minutes")
        }</span>
        <span class="cov8" title="1">m.filters = filters
        return nil</span>
}

func populateMinFilter(dst *filterState, value string) error <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">minutes, err := strconv.Atoi(value)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid min minutes: %q", value)
        }</span>
        <span class="cov8" title="1">if minutes &lt; 0 </span><span class="cov8" title="1">{
                return errors.New("min minutes must be positive")
        }</span>
        <span class="cov8" title="1">dst.minEnabled = true
        dst.minMinutes = minutes
        return nil</span>
}

func populateMaxFilter(dst *filterState, value string) error <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">minutes, err := strconv.Atoi(value)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid max minutes: %q", value)
        }</span>
        <span class="cov8" title="1">if minutes &lt; 0 </span><span class="cov8" title="1">{
                return errors.New("max minutes must be positive")
        }</span>
        <span class="cov8" title="1">dst.maxEnabled = true
        dst.maxMinutes = minutes
        return nil</span>
}

func (m *model) resetFilters() <span class="cov8" title="1">{
        m.filters = filterState{}
        for i := range m.inputs.fields </span><span class="cov8" title="1">{
                m.inputs.fields[i].SetValue("")
        }</span>
}

func (m *model) updateFilterInputs(msg tea.Msg) (filterInputs, tea.Cmd) <span class="cov8" title="1">{
        inputs := m.inputs
        var cmds []tea.Cmd
        for i := range inputs.fields </span><span class="cov8" title="1">{
                var cmd tea.Cmd
                inputs.fields[i], cmd = inputs.fields[i].Update(msg)
                cmds = append(cmds, cmd)
        }</span>
        <span class="cov8" title="1">return inputs, tea.Batch(cmds...)</span>
}

func (m model) describeFilters() string <span class="cov8" title="1">{
        parts := []string{}
        if m.filters.name != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("name contains %q", m.filters.name))
        }</span>
        <span class="cov8" title="1">if m.filters.tags != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("tags contain %q", m.filters.tags))
        }</span>
        <span class="cov8" title="1">if m.filters.minEnabled </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("&gt;=%d min", m.filters.minMinutes))
        }</span>
        <span class="cov8" title="1">if m.filters.maxEnabled </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("&lt;=%d min", m.filters.maxMinutes))
        }</span>
        <span class="cov8" title="1">if len(parts) == 0 </span><span class="cov0" title="0">{
                return "(none)"
        }</span>
        <span class="cov8" title="1">return strings.Join(parts, ", ")</span>
}

func (m *model) passesFilters(v video) bool <span class="cov8" title="1">{
        if m.filters.name != "" &amp;&amp; !strings.Contains(strings.ToLower(v.Name), strings.ToLower(m.filters.name)) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">durMinutes := int(v.Duration.Round(time.Minute) / time.Minute)
        if m.filters.minEnabled &amp;&amp; (v.Duration == 0 || durMinutes &lt; m.filters.minMinutes) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if m.filters.maxEnabled &amp;&amp; (v.Duration == 0 || durMinutes &gt; m.filters.maxMinutes) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if m.filters.tags != "" </span><span class="cov8" title="1">{
                query := strings.ToLower(m.filters.tags)
                matched := false
                for _, tag := range v.Tags </span><span class="cov8" title="1">{
                        if strings.Contains(strings.ToLower(tag), query) </span><span class="cov8" title="1">{
                                matched = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (m *model) renderFilterModal() string <span class="cov8" title="1">{
        var b strings.Builder
        b.WriteString("Filter videos\n")
        b.WriteString("(Enter to apply, Esc to cancel)\n\n")
        labels := []string{"Name contains:", "Min length (minutes):", "Max length (minutes):", "Tags contain:"}
        for i, field := range m.inputs.fields </span><span class="cov8" title="1">{
                line := fmt.Sprintf("%s %s", labels[i], field.View())
                if i == m.inputs.focus </span><span class="cov8" title="1">{
                        line = highlightStyle.Render(line)
                }</span>
                <span class="cov8" title="1">b.WriteString(line)
                b.WriteString("\n")</span>
        }
        <span class="cov8" title="1">if m.filters.minEnabled || m.filters.maxEnabled || m.filters.name != "" </span><span class="cov0" title="0">{
                b.WriteString("\nCurrent filter: ")
                b.WriteString(m.describeFilters())
                b.WriteString("\n")
        }</span>
        <span class="cov8" title="1">return filterStyle.Render(b.String())</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import "sync"

type loadProgress struct {
        mu        sync.Mutex
        total     int
        processed int
        done      bool
}

func (p *loadProgress) Reset() <span class="cov8" title="1">{
        if p == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">p.mu.Lock()
        p.total = 0
        p.processed = 0
        p.done = false
        p.mu.Unlock()</span>
}

func (p *loadProgress) SetTotal(total int) <span class="cov8" title="1">{
        if p == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">p.mu.Lock()
        p.total = total
        p.mu.Unlock()</span>
}

func (p *loadProgress) Increment() <span class="cov8" title="1">{
        if p == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">p.mu.Lock()
        p.processed++
        p.mu.Unlock()</span>
}

func (p *loadProgress) MarkDone() <span class="cov8" title="1">{
        if p == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">p.mu.Lock()
        p.done = true
        p.mu.Unlock()</span>
}

func (p *loadProgress) Snapshot() (processed, total int, done bool) <span class="cov8" title="1">{
        if p == nil </span><span class="cov0" title="0">{
                return 0, 0, true
        }</span>
        <span class="cov8" title="1">p.mu.Lock()
        defer p.mu.Unlock()
        return p.processed, p.total, p.done</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"
        "io/fs"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "time"

        tea "github.com/charmbracelet/bubbletea"

        "codeberg.org/snonux/yoga/internal/tags"
)

func loadVideosCmd(root, cachePath string, progress *loadProgress) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                cache, cacheErr := loadDurationCache(cachePath)
                videos, pending, tagErr, err := loadVideos(root, cache, progress)
                if progress != nil </span><span class="cov8" title="1">{
                        progress.MarkDone()
                }</span>
                <span class="cov8" title="1">return videosLoadedMsg{videos: videos, err: err, cacheErr: cacheErr, pending: pending, cache: cache, tagErr: tagErr}</span>
        }
}

func progressTickerCmd(progress *loadProgress) tea.Cmd <span class="cov8" title="1">{
        if progress == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return tea.Tick(200*time.Millisecond, func(time.Time) tea.Msg </span><span class="cov8" title="1">{
                processed, total, done := progress.Snapshot()
                return progressUpdateMsg{processed: processed, total: total, done: done}
        }</span>)
}

func loadVideos(root string, cache *durationCache, progress *loadProgress) ([]video, []string, error, error) <span class="cov8" title="1">{
        paths, err := collectVideoPaths(root)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">if progress != nil </span><span class="cov8" title="1">{
                progress.SetTotal(len(paths))
        }</span>
        <span class="cov8" title="1">videos := make([]video, 0, len(paths))
        pending := make([]string, 0)
        var tagErrors []string
        for _, path := range paths </span><span class="cov8" title="1">{
                info, statErr := os.Stat(path)
                if statErr != nil </span><span class="cov8" title="1">{
                        videos = append(videos, video{Name: filepath.Base(path), Path: path, Err: statErr})
                        increment(progress)
                        continue</span>
                }
                <span class="cov8" title="1">dur := cachedDuration(cache, path, info)
                if dur == 0 </span><span class="cov8" title="1">{
                        pending = append(pending, path)
                }</span>
                <span class="cov8" title="1">tagList, tagErr := tags.Load(path)
                if tagErr != nil </span><span class="cov0" title="0">{
                        tagErrors = append(tagErrors, fmt.Sprintf("%s: %v", filepath.Base(path), tagErr))
                }</span>
                <span class="cov8" title="1">videos = append(videos, video{
                        Name:     filepath.Base(path),
                        Path:     path,
                        Duration: dur,
                        ModTime:  info.ModTime(),
                        Size:     info.Size(),
                        Tags:     tagList,
                })
                increment(progress)</span>
        }
        <span class="cov8" title="1">return videos, pending, joinErrors(tagErrors), nil</span>
}

func joinErrors(messages []string) error <span class="cov8" title="1">{
        if len(messages) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New(strings.Join(messages, "; "))</span>
}

func increment(progress *loadProgress) <span class="cov8" title="1">{
        if progress != nil </span><span class="cov8" title="1">{
                progress.Increment()
        }</span>
}

func cachedDuration(cache *durationCache, path string, info os.FileInfo) time.Duration <span class="cov8" title="1">{
        if cache == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">dur, ok := cache.Lookup(path, info)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return dur</span>
}

func collectVideoPaths(root string) ([]string, error) <span class="cov8" title="1">{
        info, err := os.Stat(root)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov0" title="0">{
                if isVideo(root) </span><span class="cov0" title="0">{
                        return []string{root}, nil
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        }
        <span class="cov8" title="1">visited := make(map[string]struct{})
        var paths []string
        if err := traverseVideoPaths(root, root, visited, &amp;paths); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">sort.Strings(paths)
        return paths, nil</span>
}

func traverseVideoPaths(displayPath, realPath string, visited map[string]struct{}, acc *[]string) error <span class="cov8" title="1">{
        resolved, err := filepath.EvalSymlinks(realPath)
        if err != nil </span><span class="cov0" title="0">{
                resolved = realPath
        }</span>
        <span class="cov8" title="1">resolved = filepath.Clean(resolved)
        if _, seen := visited[resolved]; seen </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">visited[resolved] = struct{}{}

        entries, err := os.ReadDir(resolved)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                displayChild := filepath.Join(displayPath, entry.Name())
                realChild := filepath.Join(resolved, entry.Name())
                mode := entry.Type()
                var info os.FileInfo
                if mode == fs.FileMode(0) </span><span class="cov8" title="1">{
                        info, err = entry.Info()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">mode = info.Mode()</span>
                }
                <span class="cov8" title="1">if mode&amp;os.ModeSymlink != 0 </span><span class="cov8" title="1">{
                        if err := handleSymlink(displayChild, realChild, visited, acc); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if mode.IsDir() </span><span class="cov0" title="0">{
                        if err := traverseVideoPaths(displayChild, realChild, visited, acc); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov8" title="1">if isVideo(displayChild) </span><span class="cov8" title="1">{
                        *acc = append(*acc, displayChild)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func handleSymlink(displayChild, realChild string, visited map[string]struct{}, acc *[]string) error <span class="cov8" title="1">{
        targetPath, err := filepath.EvalSymlinks(realChild)
        if err != nil </span><span class="cov8" title="1">{
                return recordIfVideo(displayChild, acc)
        }</span>
        <span class="cov8" title="1">targetInfo, err := os.Stat(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return recordIfVideo(displayChild, acc)
        }</span>
        <span class="cov8" title="1">if targetInfo.IsDir() </span><span class="cov8" title="1">{
                return traverseVideoPaths(displayChild, targetPath, visited, acc)
        }</span>
        <span class="cov0" title="0">if isVideo(displayChild) || isVideo(targetPath) </span><span class="cov0" title="0">{
                *acc = append(*acc, displayChild)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func recordIfVideo(path string, acc *[]string) error <span class="cov8" title="1">{
        if isVideo(path) </span><span class="cov8" title="1">{
                *acc = append(*acc, path)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func probeDurationsCmd(path string, cache *durationCache) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                dur, err := probeDuration(path)
                if err == nil &amp;&amp; cache != nil </span><span class="cov0" title="0">{
                        if info, statErr := os.Stat(path); statErr == nil </span><span class="cov0" title="0">{
                                _ = cache.Record(path, info, dur)
                        }</span>
                }
                <span class="cov8" title="1">return durationUpdateMsg{path: path, duration: dur, err: err}</span>
        }
}

func probeDuration(path string) (time.Duration, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
        defer cancel()

        cmd := exec.CommandContext(ctx, "ffprobe", "-v", "error", "-show_entries", "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", path)
        out, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">raw := strings.TrimSpace(string(out))
        if raw == "" </span><span class="cov0" title="0">{
                return 0, errors.New("empty duration")
        }</span>
        <span class="cov8" title="1">seconds, err := strconv.ParseFloat(raw, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return time.Duration(seconds * float64(time.Second)), nil</span>
}

func playVideoCmd(path, crop string) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                args := buildVLCArgs(path, crop)
                cmd := exec.Command("vlc", args...)
                if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                        return playVideoMsg{path: path, err: err}
                }</span>
                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{ _ = cmd.Wait() }</span>()
                <span class="cov8" title="1">return playVideoMsg{path: path}</span>
        }
}

func buildVLCArgs(path, crop string) []string <span class="cov8" title="1">{
        args := []string{}
        if crop != "" </span><span class="cov0" title="0">{
                args = append(args, "--crop", crop)
        }</span>
        <span class="cov8" title="1">return append(args, path)</span>
}

func isVideo(path string) bool <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(path))
        _, ok := videoExtensions[ext]
        return ok
}</span>

// CollectVideoPathsForTest exposes collectVideoPaths for unit testing.
func CollectVideoPathsForTest(root string) ([]string, error) <span class="cov8" title="1">{
        return collectVideoPaths(root)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "fmt"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/charmbracelet/bubbles/table"
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

type sortField int

const (
        sortByName sortField = iota
        sortByDuration
        sortByAge
)

const (
        preferredNameColumnWidth     = 40
        preferredDurationColumnWidth = 12
        preferredAgeColumnWidth      = 14
        preferredTagsColumnWidth     = 28
        nameColumnFloorWidth         = 16
        durationColumnFloorWidth     = 8
        ageColumnFloorWidth          = 10
        tagsColumnFloorWidth         = 12
)

type model struct {
        table            table.Model
        videos           []video
        filtered         []video
        filters          filterState
        inputs           filterInputs
        showFilters      bool
        editingTags      bool
        sortField        sortField
        sortAscending    bool
        statusMessage    string
        loading          bool
        err              error
        root             string
        progress         *loadProgress
        cachePath        string
        cache            *durationCache
        pendingDurations []string
        durationTotal    int
        durationDone     int
        durationInFlight int
        cropValue        string
        cropEnabled      bool
        tagInput         textinput.Model
        tagEditPath      string
        baseStatus       string
        showHelp         bool
        viewportWidth    int
}

func newModel(opts Options) (model, error) <span class="cov8" title="1">{
        tbl := buildTable()
        inputs := buildFilterInputs()
        inputs.fields[0].Focus()
        tagInput := buildTagInput()

        progress := &amp;loadProgress{}
        cachePath := filepath.Join(opts.Root, ".video_duration_cache.json")

        return model{
                table:         tbl,
                inputs:        inputs,
                tagInput:      tagInput,
                sortField:     sortByName,
                sortAscending: true,
                statusMessage: "Scanning for videos...",
                loading:       true,
                root:          opts.Root,
                progress:      progress,
                cachePath:     cachePath,
                cropValue:     opts.Crop,
                cropEnabled:   opts.Crop != "",
                showHelp:      true,
        }, nil
}</span>

func buildTable() table.Model <span class="cov8" title="1">{
        columns := makeColumns(
                preferredNameColumnWidth,
                preferredDurationColumnWidth,
                preferredAgeColumnWidth,
                preferredTagsColumnWidth,
        )
        tbl := table.New(
                table.WithColumns(columns),
                table.WithFocused(true),
                table.WithHeight(15),
        )
        tbl.SetStyles(table.DefaultStyles())
        return tbl
}</span>

func buildFilterInputs() filterInputs <span class="cov8" title="1">{
        nameInput := textinput.New()
        nameInput.Placeholder = "substring"
        nameInput.Prompt = "Name: "
        nameInput.CharLimit = 256

        minInput := textinput.New()
        minInput.Placeholder = "min minutes"
        minInput.Prompt = "Min minutes: "
        minInput.CharLimit = 4

        maxInput := textinput.New()
        maxInput.Placeholder = "max minutes"
        maxInput.Prompt = "Max minutes: "
        maxInput.CharLimit = 4

        tagInput := textinput.New()
        tagInput.Placeholder = "tag substring"
        tagInput.Prompt = "Tags: "
        tagInput.CharLimit = 256

        return filterInputs{
                fields: []textinput.Model{nameInput, minInput, maxInput, tagInput},
                focus:  0,
        }
}</span>

func buildTagInput() textinput.Model <span class="cov8" title="1">{
        input := textinput.New()
        input.Placeholder = "comma-separated tags"
        input.Prompt = "Tags: "
        input.CharLimit = 512
        return input
}</span>

func makeColumns(nameWidth, durationWidth, ageWidth, tagsWidth int) []table.Column <span class="cov8" title="1">{
        return []table.Column{
                {Title: headerStyle.Render("Name"), Width: nameWidth},
                {Title: headerStyle.Render("Duration"), Width: durationWidth},
                {Title: headerStyle.Render("Age"), Width: ageWidth},
                {Title: headerStyle.Render("Tags"), Width: tagsWidth},
        }
}</span>

func (m model) Init() tea.Cmd <span class="cov8" title="1">{
        if m.progress != nil </span><span class="cov8" title="1">{
                m.progress.Reset()
        }</span>
        <span class="cov8" title="1">loadCmd := loadVideosCmd(m.root, m.cachePath, m.progress)
        if m.progress != nil </span><span class="cov8" title="1">{
                return tea.Batch(loadCmd, progressTickerCmd(m.progress))
        }</span>
        <span class="cov0" title="0">return loadCmd</span>
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch typed := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                return m.handleKeyMsg(typed)</span>
        case progressUpdateMsg:<span class="cov8" title="1">
                return m.handleProgressUpdate(typed)</span>
        case durationUpdateMsg:<span class="cov8" title="1">
                return m.handleDurationUpdate(typed)</span>
        case videosLoadedMsg:<span class="cov8" title="1">
                return m.handleVideosLoaded(typed)</span>
        case playVideoMsg:<span class="cov8" title="1">
                return m.handlePlayVideo(typed), nil</span>
        case reindexVideosMsg:<span class="cov0" title="0">
                return m.handleReindexVideos(typed)</span>
        case tagsSavedMsg:<span class="cov0" title="0">
                return m.handleTagsSaved(typed)</span>
        case tea.WindowSizeMsg:<span class="cov8" title="1">
                return m.handleWindowSize(typed)</span>
        default:<span class="cov0" title="0">
                return m.updateTable(msg)</span>
        }
}

func (m model) View() string <span class="cov8" title="1">{
        if m.loading </span><span class="cov0" title="0">{
                return statusStyle.Render("Loading videos, please wait...")
        }</span>
        <span class="cov8" title="1">body := m.renderBody()
        if m.editingTags </span><span class="cov0" title="0">{
                return body + "\n\n" + m.renderTagModal()
        }</span>
        <span class="cov8" title="1">if m.showFilters </span><span class="cov0" title="0">{
                return body + "\n\n" + m.renderFilterModal()
        }</span>
        <span class="cov8" title="1">return body</span>
}

func (m model) renderBody() string <span class="cov8" title="1">{
        helpLines := []string{
                "↑/↓ navigate  •  enter play  •  s sort  •  / filter  •  c crop  •  t edit tags  •  i re-index  •  q quit",
        }
        info := statusStyle.Render(m.statusText())
        progressLine := m.renderProgressLine()
        content := tableStyle.Render(m.table.View())
        parts := []string{content}
        if progressLine != "" </span><span class="cov0" title="0">{
                parts = append(parts, progressLine)
        }</span>
        <span class="cov8" title="1">parts = append(parts, info)
        if m.showHelp </span><span class="cov8" title="1">{
                help := strings.Join(helpLines, "\n")
                parts = append(parts, help)
        }</span>
        <span class="cov8" title="1">return strings.Join(parts, "\n")</span>
}

func (m model) statusText() string <span class="cov8" title="1">{
        status := strings.TrimSpace(m.statusMessage)
        base := strings.TrimSpace(m.baseStatus)
        if base == "" </span><span class="cov8" title="1">{
                return status
        }</span>
        <span class="cov8" title="1">if status == "" || status == base </span><span class="cov8" title="1">{
                return base
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s • %s", base, status)</span>
}

func (m model) showHelpBar() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if m.showHelp </span><span class="cov0" title="0">{
                return m, nil
        }</span>
        <span class="cov8" title="1">m.showHelp = true
        if strings.Contains(m.statusMessage, "Help hidden") </span><span class="cov8" title="1">{
                m.statusMessage = ""
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func (m model) hideHelpBar() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if !m.showHelp </span><span class="cov0" title="0">{
                return m, nil
        }</span>
        <span class="cov8" title="1">m.showHelp = false
        m.statusMessage = "Help hidden (press h to show)"
        return m, nil</span>
}

func (m model) handleWindowSize(msg tea.WindowSizeMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.viewportWidth = msg.Width
        m.resizeColumns(msg.Width)
        tbl, cmd := m.table.Update(msg)
        m.table = tbl
        if cmd == nil </span><span class="cov8" title="1">{
                return m, nil
        }</span>
        <span class="cov0" title="0">return m, cmd</span>
}

func (m *model) resizeColumns(totalWidth int) <span class="cov8" title="1">{
        if totalWidth &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">frame := tableStyle.GetHorizontalFrameSize()
        contentWidth := totalWidth - frame
        minWidth := nameColumnFloorWidth + durationColumnFloorWidth + ageColumnFloorWidth + tagsColumnFloorWidth
        if contentWidth &lt; minWidth </span><span class="cov0" title="0">{
                contentWidth = minWidth
        }</span>
        <span class="cov8" title="1">preferred := preferredNameColumnWidth + preferredDurationColumnWidth + preferredAgeColumnWidth + preferredTagsColumnWidth
        nameWidth := preferredNameColumnWidth
        durationWidth := preferredDurationColumnWidth
        ageWidth := preferredAgeColumnWidth
        tagsWidth := preferredTagsColumnWidth
        if contentWidth &gt;= preferred </span><span class="cov8" title="1">{
                extra := contentWidth - preferred
                nameWidth += extra
        }</span> else<span class="cov8" title="1"> {
                deficit := preferred - contentWidth
                if deficit &gt; 0 </span><span class="cov8" title="1">{
                        reduce := min(deficit, nameWidth-nameColumnFloorWidth)
                        nameWidth -= reduce
                        deficit -= reduce
                }</span>
                <span class="cov8" title="1">if deficit &gt; 0 </span><span class="cov8" title="1">{
                        reduce := min(deficit, tagsWidth-tagsColumnFloorWidth)
                        tagsWidth -= reduce
                        deficit -= reduce
                }</span>
                <span class="cov8" title="1">if deficit &gt; 0 </span><span class="cov0" title="0">{
                        reduce := min(deficit, ageWidth-ageColumnFloorWidth)
                        ageWidth -= reduce
                        deficit -= reduce
                }</span>
                <span class="cov8" title="1">if deficit &gt; 0 </span><span class="cov0" title="0">{
                        reduce := min(deficit, durationWidth-durationColumnFloorWidth)
                        durationWidth -= reduce
                }</span>
        }
        <span class="cov8" title="1">m.table.SetColumns(makeColumns(nameWidth, durationWidth, ageWidth, tagsWidth))
        m.table.SetWidth(contentWidth)</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (m model) renderProgressLine() string <span class="cov8" title="1">{
        if m.durationTotal == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">bar := renderProgressBar(m.durationDone, m.durationTotal, 24)
        return statusStyle.Render(fmt.Sprintf("Duration scan %s %d/%d", bar, m.durationDone, m.durationTotal))</span>
}

func (m model) updateTable(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        tbl, cmd := m.table.Update(msg)
        m.table = tbl
        return m, cmd
}</span>

func (m model) handlePlayVideo(msg playVideoMsg) model <span class="cov8" title="1">{
        if msg.err != nil </span><span class="cov8" title="1">{
                m.statusMessage = fmt.Sprintf("Failed to launch VLC: %v", msg.err)
                return m
        }</span>
        <span class="cov8" title="1">m.statusMessage = fmt.Sprintf("Playing via VLC: %s", trimPath(msg.path))
        return m</span>
}

func (m model) handleReindexVideos(msg reindexVideosMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        m.statusMessage = "Re-indexing videos..."
        return m, loadVideosCmd(m.root, m.cachePath, m.progress)
}</span>

func (m model) handleVideosLoaded(msg videosLoadedMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.loading = false
        if msg.err != nil </span><span class="cov0" title="0">{
                m.err = msg.err
                m.statusMessage = fmt.Sprintf("error: %v", msg.err)
        }</span>

        <span class="cov8" title="1">if len(m.videos) == 0 </span><span class="cov8" title="1">{
                m.videos = msg.videos
        }</span> else<span class="cov0" title="0"> {
                existingVideos := make(map[string]int)
                for i, v := range m.videos </span><span class="cov0" title="0">{
                        existingVideos[v.Path] = i
                }</span>

                <span class="cov0" title="0">for _, newVideo := range msg.videos </span><span class="cov0" title="0">{
                        if i, ok := existingVideos[newVideo.Path]; ok </span><span class="cov0" title="0">{
                                m.videos[i] = newVideo
                        }</span> else<span class="cov0" title="0"> {
                                m.videos = append(m.videos, newVideo)
                        }</span>
                }
        }

        <span class="cov8" title="1">m.cache = msg.cache
        m.pendingDurations = msg.pending
        m.durationTotal = len(msg.pending)
        m.durationDone = 0
        m.applyFiltersAndSort()
        m.updateStatusAfterLoad(msg)
        m.durationInFlight = 0
        if len(msg.pending) == 0 </span><span class="cov8" title="1">{
                return m, nil
        }</span>
        <span class="cov8" title="1">cmd := m.startDurationWorkers()
        return m, cmd</span>
}

func (m *model) updateStatusAfterLoad(msg videosLoadedMsg) <span class="cov8" title="1">{
        if len(m.filtered) == 0 </span><span class="cov0" title="0">{
                m.baseStatus = "No videos found"
                m.statusMessage = m.baseStatus
                return
        }</span>
        <span class="cov8" title="1">status := ""
        if len(msg.pending) &gt; 0 </span><span class="cov8" title="1">{
                status = fmt.Sprintf("Loaded %d videos, probing durations...", len(m.filtered))
                if msg.cacheErr != nil </span><span class="cov8" title="1">{
                        status = fmt.Sprintf("Loaded %d videos (cache warning: %v), probing durations...", len(m.filtered), msg.cacheErr)
                }</span>
        } else<span class="cov8" title="1"> {
                status = fmt.Sprintf("Loaded %d videos", len(m.filtered))
                if msg.cacheErr != nil </span><span class="cov8" title="1">{
                        status = fmt.Sprintf("Loaded %d videos (cache warning: %v)", len(m.filtered), msg.cacheErr)
                }</span>
        }
        <span class="cov8" title="1">if msg.tagErr != nil </span><span class="cov8" title="1">{
                status = fmt.Sprintf("%s (tag warning: %v)", status, msg.tagErr)
        }</span>
        <span class="cov8" title="1">m.baseStatus = status
        m.statusMessage = status</span>
}

func (m *model) startDurationWorkers() tea.Cmd <span class="cov8" title="1">{
        if len(m.pendingDurations) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">workers := runtime.NumCPU()
        if workers &lt; 1 </span><span class="cov0" title="0">{
                workers = 1
        }</span>
        <span class="cov8" title="1">if workers &gt; 6 </span><span class="cov8" title="1">{
                workers = 6
        }</span>
        <span class="cov8" title="1">if workers &gt; len(m.pendingDurations) </span><span class="cov8" title="1">{
                workers = len(m.pendingDurations)
        }</span>
        <span class="cov8" title="1">cmds := make([]tea.Cmd, 0, workers)
        for i := 0; i &lt; workers; i++ </span><span class="cov8" title="1">{
                cmd := m.dequeueDurationCmd()
                if cmd != nil </span><span class="cov8" title="1">{
                        cmds = append(cmds, cmd)
                }</span>
        }
        <span class="cov8" title="1">if len(cmds) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return tea.Batch(cmds...)</span>
}

func (m *model) dequeueDurationCmd() tea.Cmd <span class="cov8" title="1">{
        if len(m.pendingDurations) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">path := m.pendingDurations[0]
        m.pendingDurations = m.pendingDurations[1:]
        m.durationInFlight++
        return probeDurationsCmd(path, m.cache)</span>
}

func (m model) activeCrop() string <span class="cov8" title="1">{
        if m.cropEnabled &amp;&amp; m.cropValue != "" </span><span class="cov8" title="1">{
                return m.cropValue
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func (m model) handleProgressUpdate(msg progressUpdateMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if !m.loading </span><span class="cov0" title="0">{
                return m, nil
        }</span>
        <span class="cov8" title="1">if msg.total == 0 &amp;&amp; msg.done </span><span class="cov8" title="1">{
                m.statusMessage = "No videos found"
                return m, nil
        }</span>
        <span class="cov8" title="1">if msg.done </span><span class="cov8" title="1">{
                m.statusMessage = fmt.Sprintf("Loaded %d videos", msg.total)
                return m, nil
        }</span>
        <span class="cov8" title="1">m.statusMessage = fmt.Sprintf("Loading videos %d/%d...", msg.processed, msg.total)
        return m, progressTickerCmd(m.progress)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "fmt"
        "path/filepath"
        "time"

        tea "github.com/charmbracelet/bubbletea"
)

func (m model) handleDurationUpdate(msg durationUpdateMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if msg.path != "" </span><span class="cov8" title="1">{
                m.updateVideoDuration(msg.path, msg.duration, msg.err)
                m.durationDone++
                m.updateStatusForDuration(msg)
        }</span>
        <span class="cov8" title="1">if m.durationInFlight &gt; 0 </span><span class="cov8" title="1">{
                m.durationInFlight--
        }</span>
        <span class="cov8" title="1">selectedPath := m.currentSelectionPath()
        m.applyFiltersAndSort()
        m.restoreSelection(selectedPath)
        if m.allDurationsResolved() </span><span class="cov8" title="1">{
                m.onDurationsComplete()
                return m, nil
        }</span>
        <span class="cov8" title="1">cmd := m.dequeueDurationCmd()
        return m, cmd</span>
}

func (m *model) updateStatusForDuration(msg durationUpdateMsg) <span class="cov8" title="1">{
        if msg.err != nil </span><span class="cov8" title="1">{
                m.statusMessage = fmt.Sprintf("Duration error for %s: %v", filepath.Base(msg.path), msg.err)
                return
        }</span>
        <span class="cov8" title="1">if m.durationTotal &gt; 0 </span><span class="cov8" title="1">{
                m.statusMessage = fmt.Sprintf("Probing durations %d/%d...", m.durationDone, m.durationTotal)
        }</span>
}

func (m model) currentSelectionPath() string <span class="cov8" title="1">{
        idx := m.table.Cursor()
        if idx &lt; 0 || idx &gt;= len(m.filtered) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return m.filtered[idx].Path</span>
}

func (m *model) restoreSelection(path string) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for i, video := range m.filtered </span><span class="cov8" title="1">{
                if video.Path == path </span><span class="cov8" title="1">{
                        m.table.SetCursor(i)
                        return
                }</span>
        }
}

func (m *model) updateVideoDuration(path string, dur time.Duration, err error) <span class="cov8" title="1">{
        for i := range m.videos </span><span class="cov8" title="1">{
                if m.videos[i].Path != path </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">m.videos[i].Duration = dur
                m.videos[i].Err = err
                return</span>
        }
}

func (m model) allDurationsResolved() bool <span class="cov8" title="1">{
        return m.durationDone &gt;= m.durationTotal &amp;&amp; m.durationInFlight == 0
}</span>

func (m *model) onDurationsComplete() <span class="cov8" title="1">{
        if m.cache != nil </span><span class="cov8" title="1">{
                if err := m.cache.Flush(); err != nil </span><span class="cov0" title="0">{
                        m.statusMessage = fmt.Sprintf("Duration cache flush error: %v", err)
                }</span> else<span class="cov8" title="1"> {
                        m.statusMessage = fmt.Sprintf("Durations ready (%d videos)", len(m.filtered))
                }</span>
                <span class="cov8" title="1">m.resetDurationState()
                return</span>
        }
        <span class="cov0" title="0">m.statusMessage = fmt.Sprintf("Durations ready (%d videos)", len(m.filtered))
        m.resetDurationState()</span>
}

func (m *model) resetDurationState() <span class="cov8" title="1">{
        m.pendingDurations = nil
        m.durationTotal = 0
        m.durationDone = 0
        m.durationInFlight = 0
}</span>



</pre>
		
		<pre class="file" id="file8" style="display: none">package app

import (
        "fmt"
        "math/rand"

        tea "github.com/charmbracelet/bubbletea"
)

func (m model) handleKeyMsg(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if cmd, handled := globalKeyHandler(msg); handled </span><span class="cov0" title="0">{
                return m, cmd
        }</span>
        <span class="cov8" title="1">if m.loading </span><span class="cov0" title="0">{
                return m, nil
        }</span>
        <span class="cov8" title="1">if m.editingTags </span><span class="cov0" title="0">{
                return m.handleTagKey(msg)
        }</span>
        <span class="cov8" title="1">if m.showFilters </span><span class="cov8" title="1">{
                return m.handleFilterKey(msg)
        }</span>
        <span class="cov8" title="1">return m.handleTableKey(msg)</span>
}

func globalKeyHandler(msg tea.KeyMsg) (tea.Cmd, bool) <span class="cov8" title="1">{
        switch msg.String() </span>{
        case "ctrl+c", "q":<span class="cov0" title="0">
                return tea.Quit, true</span>
        default:<span class="cov8" title="1">
                return nil, false</span>
        }
}

func (m model) handleFilterKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg.String() </span>{
        case "esc":<span class="cov0" title="0">
                m.showFilters = false
                m.statusMessage = "Filter closed"
                return m, nil</span>
        case "enter":<span class="cov8" title="1">
                cmd := m.applyFiltersFromInputs()
                return m, cmd</span>
        case "tab":<span class="cov8" title="1">
                m.inputs.focus = (m.inputs.focus + 1) % len(m.inputs.fields)</span>
        case "shift+tab":<span class="cov8" title="1">
                m.inputs.focus = (m.inputs.focus - 1 + len(m.inputs.fields)) % len(m.inputs.fields)</span>
        }
        <span class="cov8" title="1">m.syncFilterFocus()
        updated, cmd := m.updateFilterInputs(msg)
        m.inputs = updated
        return m, cmd</span>
}

func (m *model) applyFiltersFromInputs() tea.Cmd <span class="cov8" title="1">{
        if err := m.applyFilterInputs(); err != nil </span><span class="cov0" title="0">{
                m.statusMessage = err.Error()
                return nil
        }</span>
        <span class="cov8" title="1">m.showFilters = false
        m.applyFiltersAndSort()
        m.statusMessage = fmt.Sprintf("Filters applied (%d videos)", len(m.filtered))
        return nil</span>
}

func (m *model) syncFilterFocus() <span class="cov8" title="1">{
        for i := range m.inputs.fields </span><span class="cov8" title="1">{
                if i == m.inputs.focus </span><span class="cov8" title="1">{
                        m.inputs.fields[i].Focus()
                        continue</span>
                }
                <span class="cov8" title="1">m.inputs.fields[i].Blur()</span>
        }
}

func (m model) handleTableKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg.String() </span>{
        case "/", "f":<span class="cov8" title="1">
                return m.openFilters()</span>
        case "enter":<span class="cov0" title="0">
                return m.playSelection()</span>
        case "n":<span class="cov0" title="0">
                return m.sortAndReport(sortByName)</span>
        case "l":<span class="cov8" title="1">
                return m.sortAndReport(sortByDuration)</span>
        case "a":<span class="cov0" title="0">
                return m.sortAndReport(sortByAge)</span>
        case "c":<span class="cov8" title="1">
                return m.toggleCrop()</span>
        case "t":<span class="cov0" title="0">
                return m.openTagEditor()</span>
        case "H":<span class="cov8" title="1">
                return m.hideHelpBar()</span>
        case "h":<span class="cov8" title="1">
                return m.showHelpBar()</span>
        case "r":<span class="cov8" title="1">
                return m.resetFilterState()</span>
        case "i":<span class="cov0" title="0">
                return m, func() tea.Msg </span><span class="cov0" title="0">{ return reindexVideosMsg{} }</span>
        case "x":<span class="cov8" title="1">
                return m.selectRandomVideo()</span>
        default:<span class="cov8" title="1">
                return m.updateTable(msg)</span>
        }
}

func (m model) openFilters() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.showFilters = true
        m.statusMessage = "Editing filters"
        return m, nil
}</span>

func (m model) playSelection() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if len(m.filtered) == 0 </span><span class="cov0" title="0">{
                return m, nil
        }</span>
        <span class="cov8" title="1">idx := m.table.Cursor()
        if idx &lt; 0 || idx &gt;= len(m.filtered) </span><span class="cov0" title="0">{
                return m, nil
        }</span>
        <span class="cov8" title="1">video := m.filtered[idx]
        m.statusMessage = fmt.Sprintf("Launching VLC: %s", video.Name)
        return m, playVideoCmd(video.Path, m.activeCrop())</span>
}

func (m model) sortAndReport(field sortField) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.toggleSort(field)
        m.applyFiltersAndSort()
        m.statusMessage = fmt.Sprintf("Sorted %d videos", len(m.filtered))
        return m, nil
}</span>

func (m model) toggleCrop() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if m.cropValue == "" </span><span class="cov0" title="0">{
                m.statusMessage = "No crop value set (start with --crop)"
                return m, nil
        }</span>
        <span class="cov8" title="1">m.cropEnabled = !m.cropEnabled
        if m.cropEnabled </span><span class="cov8" title="1">{
                m.statusMessage = fmt.Sprintf("Crop enabled (%s)", m.cropValue)
                return m, nil
        }</span>
        <span class="cov8" title="1">m.statusMessage = "Crop disabled"
        return m, nil</span>
}

func (m model) resetFilterState() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.resetFilters()
        m.applyFiltersAndSort()
        m.statusMessage = fmt.Sprintf("Filters cleared (%d videos)", len(m.filtered))
        return m, nil
}</span>

func (m model) selectRandomVideo() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if len(m.filtered) == 0 </span><span class="cov8" title="1">{
                m.statusMessage = "No videos to select from"
                return m, nil
        }</span>
        <span class="cov8" title="1">idx := rand.Intn(len(m.filtered))
        m.table.SetCursor(idx)
        video := m.filtered[idx]
        m.statusMessage = fmt.Sprintf("Randomly selected: %s", video.Name)
        return m, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package app

import (
        "sort"
        "strings"

        "github.com/charmbracelet/bubbles/table"
)

func (m *model) toggleSort(target sortField) <span class="cov8" title="1">{
        if m.sortField == target </span><span class="cov8" title="1">{
                m.sortAscending = !m.sortAscending
                return
        }</span>
        <span class="cov8" title="1">m.sortField = target
        m.sortAscending = true</span>
}

func (m *model) applyFiltersAndSort() <span class="cov8" title="1">{
        filtered := make([]video, 0, len(m.videos))
        for _, v := range m.videos </span><span class="cov8" title="1">{
                if m.passesFilters(v) </span><span class="cov8" title="1">{
                        filtered = append(filtered, v)
                }</span>
        }
        <span class="cov8" title="1">sort.Slice(filtered, func(i, j int) bool </span><span class="cov8" title="1">{
                return m.less(filtered[i], filtered[j])
        }</span>)
        <span class="cov8" title="1">m.filtered = filtered
        m.updateTableRows()</span>
}

func (m *model) less(a, b video) bool <span class="cov8" title="1">{
        var less bool
        switch m.sortField </span>{
        case sortByName:<span class="cov8" title="1">
                less = strings.ToLower(a.Name) &lt; strings.ToLower(b.Name)</span>
        case sortByDuration:<span class="cov8" title="1">
                less = a.Duration &lt; b.Duration</span>
        case sortByAge:<span class="cov0" title="0">
                less = a.ModTime.Before(b.ModTime)</span>
        }
        <span class="cov8" title="1">if m.sortAscending </span><span class="cov8" title="1">{
                return less
        }</span>
        <span class="cov0" title="0">return !less</span>
}

func (m *model) updateTableRows() <span class="cov8" title="1">{
        rows := make([]table.Row, 0, len(m.filtered))
        for _, v := range m.filtered </span><span class="cov8" title="1">{
                rows = append(rows, videoRow(v))
        }</span>
        <span class="cov8" title="1">m.table.SetRows(rows)
        if len(rows) &gt; 0 </span><span class="cov8" title="1">{
                m.table.SetCursor(0)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package app

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

func (m model) openTagEditor() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if len(m.filtered) == 0 </span><span class="cov0" title="0">{
                m.statusMessage = "No videos to edit"
                return m, nil
        }</span>
        <span class="cov8" title="1">cursor := m.table.Cursor()
        if cursor &lt; 0 || cursor &gt;= len(m.filtered) </span><span class="cov0" title="0">{
                m.statusMessage = "No selection"
                return m, nil
        }</span>
        <span class="cov8" title="1">video := m.filtered[cursor]
        m.editingTags = true
        m.tagEditPath = video.Path
        m.tagInput = cloneInput(m.tagInput)
        m.tagInput.SetValue(strings.Join(video.Tags, ", "))
        m.tagInput.CursorEnd()
        m.tagInput.Focus()
        m.statusMessage = fmt.Sprintf("Editing tags for %s", video.Name)
        return m, nil</span>
}

func (m model) handleTagKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg.String() </span>{
        case "esc":<span class="cov0" title="0">
                m.editingTags = false
                m.tagEditPath = ""
                m.tagInput.Blur()
                m.statusMessage = "Tag edit cancelled"
                return m, nil</span>
        case "enter":<span class="cov8" title="1">
                return m.commitTags()</span>
        }
        <span class="cov0" title="0">var cmd tea.Cmd
        m.tagInput, cmd = m.tagInput.Update(msg)
        return m, cmd</span>
}

func (m model) commitTags() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if m.tagEditPath == "" </span><span class="cov0" title="0">{
                m.editingTags = false
                m.tagInput.Blur()
                m.statusMessage = "No video selected"
                return m, nil
        }</span>
        <span class="cov8" title="1">value := m.tagInput.Value()
        tags := parseTagInput(value)
        m.editingTags = false
        m.tagInput.Blur()
        path := m.tagEditPath
        m.tagEditPath = ""
        name := filepath.Base(path)
        m.statusMessage = fmt.Sprintf("Saving tags for %s", name)
        return m, saveTagsCmd(path, tags)</span>
}

func (m model) handleTagsSaved(msg tagsSavedMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if msg.err != nil </span><span class="cov0" title="0">{
                m.editingTags = false
                m.tagEditPath = ""
                m.tagInput.Blur()
                m.showHelp = true
                m.statusMessage = fmt.Sprintf("Tag save error: %v", msg.err)
                return m, nil
        }</span>
        <span class="cov8" title="1">m.editingTags = false
        m.tagEditPath = ""
        m.tagInput.Blur()
        m.showHelp = true
        m.setVideoTags(msg.path, msg.tags)
        m.applyFiltersAndSort()
        m.restoreSelection(msg.path)
        if len(msg.tags) == 0 </span><span class="cov0" title="0">{
                m.statusMessage = "Tags cleared"
                return m, nil
        }</span>
        <span class="cov8" title="1">m.statusMessage = fmt.Sprintf("Tags updated (%d)", len(msg.tags))
        return m, nil</span>
}

func (m *model) setVideoTags(path string, tags []string) <span class="cov8" title="1">{
        for i := range m.videos </span><span class="cov8" title="1">{
                if m.videos[i].Path == path </span><span class="cov8" title="1">{
                        m.videos[i].Tags = append([]string{}, tags...)
                        return
                }</span>
        }
}

func parseTagInput(value string) []string <span class="cov8" title="1">{
        if strings.TrimSpace(value) == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.Split(value, ",")
        var tags []string
        seen := make(map[string]struct{}, len(parts))
        for _, part := range parts </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(part)
                if trimmed == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">lower := strings.ToLower(trimmed)
                if _, ok := seen[lower]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[lower] = struct{}{}
                tags = append(tags, trimmed)</span>
        }
        <span class="cov8" title="1">return tags</span>
}

func cloneInput(in textinput.Model) textinput.Model <span class="cov8" title="1">{
        copy := in
        return copy
}</span>

func (m model) renderTagModal() string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString("Edit tags\n")
        b.WriteString("(comma separated)\n\n")
        b.WriteString(m.tagInput.View())
        b.WriteString("\n\n")
        b.WriteString("Enter to save, Esc to cancel")
        return filterStyle.Render(b.String())
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package app

import (
        "codeberg.org/snonux/yoga/internal/tags"
        tea "github.com/charmbracelet/bubbletea"
)

func saveTagsCmd(path string, entries []string) tea.Cmd <span class="cov8" title="1">{
        // Copy slice to avoid accidental mutation after scheduling command.
        values := append([]string{}, entries...)
        return func() tea.Msg </span><span class="cov8" title="1">{
                if err := tags.Save(path, values); err != nil </span><span class="cov0" title="0">{
                        return tagsSavedMsg{path: path, err: err}
                }</span>
                <span class="cov8" title="1">sanitized, err := tags.Load(path)
                if err != nil </span><span class="cov0" title="0">{
                        return tagsSavedMsg{path: path, err: err}
                }</span>
                <span class="cov8" title="1">return tagsSavedMsg{path: path, tags: sanitized}</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package app

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/charmbracelet/bubbles/table"
)

func videoRow(v video) table.Row <span class="cov8" title="1">{
        duration := "(unknown)"
        if v.Duration &gt; 0 </span><span class="cov8" title="1">{
                duration = formatDuration(v.Duration)
        }</span>
        <span class="cov8" title="1">age := humanizeAge(v.ModTime)
        tags := formatTags(v.Tags)
        if v.Err != nil </span><span class="cov8" title="1">{
                duration = "!" + v.Err.Error()
        }</span>
        <span class="cov8" title="1">return table.Row{v.Name, duration, age, tags}</span>
}

func renderProgressBar(done, total, width int) string <span class="cov8" title="1">{
        if width &lt;= 0 || total &lt;= 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if done &lt; 0 </span><span class="cov8" title="1">{
                done = 0
        }</span>
        <span class="cov8" title="1">if done &gt; total </span><span class="cov0" title="0">{
                done = total
        }</span>
        <span class="cov8" title="1">filled := int(float64(done) / float64(total) * float64(width))
        if filled &gt; width </span><span class="cov0" title="0">{
                filled = width
        }</span>
        <span class="cov8" title="1">bar := strings.Repeat("#", filled) + strings.Repeat("-", width-filled)
        return fmt.Sprintf("[%s]", bar)</span>
}

func formatDuration(d time.Duration) string <span class="cov8" title="1">{
        if d &lt;= 0 </span><span class="cov0" title="0">{
                return "--"
        }</span>
        <span class="cov8" title="1">totalSeconds := int(d.Seconds() + 0.5)
        hours := totalSeconds / 3600
        minutes := (totalSeconds % 3600) / 60
        seconds := totalSeconds % 60
        if hours &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d:%02d:%02d", hours, minutes, seconds)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%02d:%02d", minutes, seconds)</span>
}

func humanizeAge(t time.Time) string <span class="cov8" title="1">{
        if t.IsZero() </span><span class="cov8" title="1">{
                return "--"
        }</span>
        <span class="cov8" title="1">dur := time.Since(t)
        if dur &lt; time.Minute </span><span class="cov8" title="1">{
                return "just now"
        }</span>
        <span class="cov8" title="1">if dur &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm ago", int(dur.Minutes()))
        }</span>
        <span class="cov8" title="1">if dur &lt; 24*time.Hour </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dh ago", int(dur.Hours()))
        }</span>
        <span class="cov0" title="0">return t.Format("2006-01-02")</span>
}

func trimPath(path string) string <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err == nil &amp;&amp; strings.HasPrefix(path, home) </span><span class="cov0" title="0">{
                return "~" + strings.TrimPrefix(path, home)
        }</span>
        <span class="cov8" title="1">return path</span>
}

func formatTags(tags []string) string <span class="cov8" title="1">{
        if len(tags) == 0 </span><span class="cov8" title="1">{
                return "--"
        }</span>
        <span class="cov8" title="1">return strings.Join(tags, ", ")</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package fsutil

import (
        "errors"
        "fmt"
        "io/fs"
        "os"
        "os/user"
        "path/filepath"
        "strings"
)

// ResolveRootPath expands and validates the supplied root path. When the
// caller did not specify a value, defaultValue is used and created on demand.
func ResolveRootPath(input, defaultValue string) (string, error) <span class="cov8" title="1">{
        value, isDefault := normalizeRootInput(input, defaultValue)
        expanded, err := expandPath(value)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("cannot expand root path %q: %w", value, err)
        }</span>
        <span class="cov8" title="1">abs, err := filepath.Abs(expanded)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("cannot resolve root path %q: %w", expanded, err)
        }</span>
        <span class="cov8" title="1">info, err := ensureRootExists(abs, isDefault)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if !info.IsDir() &amp;&amp; !info.Mode().IsRegular() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("root path %q is not a file or directory", abs)
        }</span>
        <span class="cov8" title="1">return abs, nil</span>
}

func normalizeRootInput(input, defaultValue string) (value string, isDefault bool) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(input)
        if trimmed == "" </span><span class="cov8" title="1">{
                return defaultValue, true
        }</span>
        <span class="cov8" title="1">return trimmed, false</span>
}

func ensureRootExists(path string, allowCreate bool) (fs.FileInfo, error) <span class="cov8" title="1">{
        info, err := os.Stat(path)
        if err == nil </span><span class="cov8" title="1">{
                return info, nil
        }</span>
        <span class="cov8" title="1">if !errors.Is(err, fs.ErrNotExist) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot access root path %q: %w", path, err)
        }</span>
        <span class="cov8" title="1">if !allowCreate </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("root path does not exist: %s", path)
        }</span>
        <span class="cov8" title="1">if mkErr := os.MkdirAll(path, 0o755); mkErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create default directory %q: %w", path, mkErr)
        }</span>
        <span class="cov8" title="1">info, err = os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot stat default directory %q: %w", path, err)
        }</span>
        <span class="cov8" title="1">return info, nil</span>
}

func expandPath(p string) (string, error) <span class="cov8" title="1">{
        if p == "" || p[0] != '~' </span><span class="cov8" title="1">{
                return p, nil
        }</span>
        <span class="cov8" title="1">if len(p) == 1 </span><span class="cov8" title="1">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return home, nil</span>
        }
        <span class="cov8" title="1">if p[1] == '/' </span><span class="cov8" title="1">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return filepath.Join(home, p[2:]), nil</span>
        }
        <span class="cov8" title="1">username, rest := splitUserPath(p)
        usr, err := user.Lookup(username)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if rest == "" </span><span class="cov8" title="1">{
                return usr.HomeDir, nil
        }</span>
        <span class="cov0" title="0">return filepath.Join(usr.HomeDir, rest), nil</span>
}

func splitUserPath(p string) (string, string) <span class="cov8" title="1">{
        sep := strings.IndexRune(p, '/')
        if sep == -1 </span><span class="cov8" title="1">{
                return p[1:], ""
        }</span>
        <span class="cov8" title="1">return p[1:sep], p[sep:]</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package tags

import (
        "encoding/json"
        "errors"
        "os"
        "path/filepath"
        "sort"
        "strings"
)

// PathFor returns the path to the tag metadata file for the given video path.
func PathFor(videoPath string) string <span class="cov8" title="1">{
        ext := filepath.Ext(videoPath)
        if strings.EqualFold(ext, ".mp4") </span><span class="cov8" title="1">{
                return strings.TrimSuffix(videoPath, ext) + ".json"
        }</span>
        <span class="cov0" title="0">return videoPath + ".json"</span>
}

// Load reads the tags associated with a video. Missing files yield an empty slice.
func Load(videoPath string) ([]string, error) <span class="cov8" title="1">{
        metadataPath := PathFor(videoPath)
        data, err := os.ReadFile(metadataPath)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">var parsed []string
        if err := json.Unmarshal(data, &amp;parsed); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return sanitize(parsed), nil</span>
}

// Save persists the tags for a video to its metadata file.
func Save(videoPath string, tagValues []string) error <span class="cov8" title="1">{
        metadataPath := PathFor(videoPath)
        cleaned := sanitize(tagValues)
        payload, err := json.MarshalIndent(cleaned, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(metadataPath, payload, 0o644)</span>
}

func sanitize(raw []string) []string <span class="cov8" title="1">{
        if len(raw) == 0 </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov8" title="1">seen := make(map[string]struct{}, len(raw))
        var cleaned []string
        for _, tag := range raw </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(tag)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">normalized := trimmed
                if _, ok := seen[normalized]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[normalized] = struct{}{}
                cleaned = append(cleaned, normalized)</span>
        }
        <span class="cov8" title="1">sort.Strings(cleaned)
        return cleaned</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
